#include <QCoreApplication>

int main()
{
    return 0;
}

///Начнем мы с написания конструктора. В этой задаче вам требуется реализовать конструктор, который принимает на вход C-style строку,
///вычисляет ее размер (без учета завершающего 0 символа) и сохраняет его в поле size, кроме того, конструктор должен аллоцировать память достаточную для хранения копии переданной строки (вместе с завершающим 0 символом),
///копирует переданную строку в выделенную память и сохраняет указатель на начало этой области памяти в поле str.


//#include <cstddef> // size_t
//#include <cstring> // strlen, strcpy

//struct String {
//    String(const char *str = "");
//    size_t size;
//    char *str;
//};


//String::String(const char *str){
//    size = strlen(str);
//    this -> str = new char [size+1]; // Правильно помню, что +1 это для нулевого символа?
//    for(size_t i = 0; i <= size;++i){
//        this -> str[i] = str[i];
//    }
//}

///Конструкторов у структуры может быть несколько. Для строки может оказаться полезным заполняющий конструктор (например, чтобы создать строку пробелов).
///Заполняющий конструктор принимает число и символ, и создает строку с заданным количеством повторений переданного символа.
///Условия налагаемые на реализацию конструктора те же самые (в поле size размер без учета завершающего 0 символа, в поле str C-style строка, т.е. с завершающим 0 символом).
///Кроме конструктора в этой задаче вам нужно также реализовать и деструктор, который освободит выделенную память.


//#include <cstddef> // size_t
//#include <cstring> // strlen, strcpy

//struct String {
//    /* Реализуйте этот конструктор */
//    String(size_t n, char c);
//    size_t size;
//    char *str;
//    /* и деструктор */
//    ~String(){          // Деконструктор можно же делать не только в теле структуры, но и String::~String(){delete[] str}?
//        delete[] str;
//    }
//};

//String::String(size_t n,char c){
//    size = n;
//    str = new char[size+1];
//    for (size_t i = 0; i < size; ++i){
//        str[i] = c;
//    }
//}

///Для работы со строками можно придумать множество полезных методов (подумайте, какие методы пригодились бы вам, и чего вам не хватает для их реализации).
///Примером такого метода может послужить метод append — он добавляет копию строки-аргумента в конец текущей строки (т.е. в конец строки, у которой он был вызван).
///Требования к реализации: при реализации вы можете заводить любые вспомогательные функции и методы. В шаблоне вы увидите объявления уже известных вам конструкторов и деструкторов, реализовывать их заново не нужно, они уже реализованы.



//#include <cstddef> // size_t
//#include <cstring> // strlen, strcpy

//struct String {
//    String(const char *str = "");
//    String(size_t n, char c);
//    ~String();

//    /* Реализуйте этот метод. */
//    void append(String &other){
//    size_t new_size = size + other.size;        // Определил размер строки
//    char * new_ptr = new char [new_size + 1];   //  Выделил память, хоть и плохо что не проинициализировал new_ptr
//    strcpy(new_ptr,str);                        // Копирую строку
//    strcat(new_ptr+size, other.str);
//    new_ptr[new_size] = '\0';                   //Добавим нулевой символ
//    delete[] str;                               //Освобождаем память
//    str = new_ptr;                              //Этого мне не хватало и я нашёл похожее решение и забрал себе(
//    size = strlen(str);
//    }
//    size_t size;
//    char *str;
//};


/// Честно, самый душный код, который я вообще на ++ писал. Я понимаю, что тут что-то не так, потому что 3 жёлтых знака этому свидетельствуют.
/// Но тут я просто уже не вывез и не понимал в чём ошибка и залез в комменты. Там конечно то ещё приключение было, в результате кое как реализовал задачу, но 13% решаемости оправданы))




/// *Код, который будет ниже*
/// Как видно, все поля этого класса закрытые, ваша задача реализовать несколько функций, которые дают полный доступ к этим полям (см. шаблон кода), несмотря на то, что они закрытые.



// * Класс Cls определен точно таким образом(оказывается эту часть кода не нужно было разыменовывать):
struct Cls {
    Cls(char c, double d, int i);
private:
    char c;
    double d;
    int i;
};

struct ClsPubl // Создаём копию класса с приватными данными
{
    ClsPubl(char _c, double _d, int _i);
public:
    char c;
    double d;
    int i;
};

// Эта функция должна предоставить доступ к полю c объекта cls.
// Обратите внимание, что возвращается ссылка на char, т. е.
// доступ предоставляется на чтение и запись.
char &get_c(Cls &cls) {
    void* voidptr = static_cast<void*>(&cls); // Приводим к void
    struct ClsPubl * p = static_cast<ClsPubl*>(voidptr); // Заменяем на нашего двойника
    return p->c; // Получаем данные из памяти
}

// Эта функция должна предоставить доступ к полю d объекта cls.
// Обратите внимание, что возвращается ссылка на double, т. е.
// доступ предоставляется на чтение и запись.
double &get_d(Cls &cls) {
    void* voidptr = static_cast<void*>(&cls); // Приводим к void
    struct ClsPubl * l = static_cast<ClsPubl*>(voidptr); // Заменяем на нашего двойника
    return l->d; // Получаем данные из памяти
}

// Эта функция должна предоставить доступ к полю i объекта cls.
// Обратите внимание, что возвращается ссылка на int, т. е.
// доступ предоставляется на чтение и запись.
int &get_i(Cls &cls) {
    void* voidptr = static_cast<void*>(&cls); // Приводим к void
    struct ClsPubl * m = static_cast<ClsPubl*>(voidptr); // Заменяем на нашего двойника
    return m->i; // Получаем данные из памяти
}


/// Немного хакинга, сразу понял, что это нестандартная задача и вспомнил,что смотрел про что-то подобное видео.
/// В результате зашёл в комменты, а там как раз об этом и говорят. Короче попал прямо в точку)
