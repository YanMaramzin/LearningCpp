#include <iostream>

int main()
{
    return 0;
}
/// В этой задаче вам нужно реализовать функцию resize.
/// Функция resize принимает на вход три аргумента: указатель на область памяти, выделенную с помощью оператора new[], размер области (size) и новый размер (new_size).
/// Функция должна выделить память размера new_size, скопировать в нее данные из переданной области памяти,
/// освободить старую область памяти и вернуть выделенную область памяти нового размера со скопированными данными.


//char *resize(const char *str, unsigned size, unsigned new_size)
//{
//    int true_size = size > new_size ? new_size : size; //Проверка объёма памяти
//    char *res = new char[new_size]; // Выдедение размера памяти new_size
//    for (int i = 0;i < true_size;i++){
//       res[i] = str[i];             // Запись в новую память данные старой
//    }
//    delete[] str;                   // Очищение
//    return res;                     // Выход из программы и возращение результатов
//}

///Реализуйте функцию getline, которая считывает поток ввода посимвольно,
///пока не достигнет конца потока или не встретит символ переноса строки ('\n'),
///и возвращает C-style строку с прочитанными символами.

//#include <iostream>
//using namespace std;

//char *getline()
//{
//    int i = 0;
//    char c;
//    char * tmp = new char[1];
//    while (cin.get(c) && (c != '\n')) {
//        i++;
//        tmp[i-1] = c;
//        char * new_tmp = new char[i+1];
//        for (int n=0; n<i; n++) new_tmp[n] = tmp[n];
//        delete [] tmp;
//        tmp = new_tmp;
//    }
//    tmp[i] = '\0';
//    return tmp;
//}

/// Напишите функцию, которая принимает на вход целочисленную матрицу M(другими словами, просто двумерный целочисленный массив)
/// размера rows×cols, и возвращает транспонированную матрицу M^T(тоже двумерный целочисленный массив) размера cols×rows.
/// Если в M на пересечении i-ой строки и j-ого столбца стояло число x, то на пересечении  j-ой строки и i-ого столбца в матрице M^T
/// тоже будет стоять число x

//int ** transpose(const int * const * m, unsigned rows, unsigned cols)
//{
//    int** new_m = new int* [cols];
//    for (int i = 0; i != cols; ++i){ // Решаем задачу "в лоб", поэтому создаю клона изначального массива
//        new_m[i] = new int[rows];    // 100% есть какое-то решение "в одну строчку"
//    }
//    for (int i = 0; i < cols; i++) {
//        for (int j = 0; j < rows; j++) { // Ну и всё, бегу по массиву и записываю транспонируемую матрицу.
//                                           // ВОООТ где вышмат пригодился (это будет единственная задача xd - шучу, вышмат самый важный предмет <3)
//            new_m[i][j] = m[j][i];
//        }
//    }
//    return new_m;
//}


/// Реализуйте функцию swap_min, которая принимает на вход двумерный массив целых чисел,
/// ищет в этом массиве строку, содержащую наименьшее среди всех элементов массива значение, и меняет эту строку местами с первой строкой массива.
/// Подумайте, как обменять строки массива, не обменивая элементы строк по-отдельности.

//void swap_min(int *m[], unsigned rows, unsigned cols)
//{
//    int min_rows = m[0][0];         // Берём за минимум первую строку
//    int minNumber = 0;              // Минимальное значение

//    for (int i = 0; i < rows; i++) {
//        for (int j = 0; j < cols; j++) {  // Бегу про массиву и просто ищу значение меньше
//            if(m[i][j] < min_rows){
//                min_rows = m[i][j];
//                minNumber = i;
//            }
//        }
//    }

//    int *tmp = m[minNumber];              //  Замена
//    m[minNumber] = m[0];
//    m[0] = tmp;

//}








